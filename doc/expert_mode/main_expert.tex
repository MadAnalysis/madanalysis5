\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url,slashed,multirow,cite,verbdef}
\usepackage{hyperref}
%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
%\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{xcolor}
\definecolor{ao}{rgb}{0.0, 0.5, 0.0}
% faire des boites
\usepackage{framed,color}
\definecolor{shadecolor}{rgb}{0.55, 0.71, 0.0}

% Tools
\newcommand{\MG}{\textsc{MadGraph}~5\_aMC@NLO}
\newcommand{\PY}{\textsc{Pythia}~8}
\newcommand{\MA}{\textsc{MadAnalysis}~5}
\newcommand{\MW}{\textsc{MadWidth}}
\newcommand{\MS}{\textsc{MadSpin}}
\newcommand{\MAnorm}{{MadAnalysis}~5}
\newcommand{\FJ}{\textsc{FastJet}}
\newcommand{\FJnorm}{{FastJet}}
\newcommand{\DEL}{\textsc{Delphes}}
\newcommand{\DELnorm}{{Delphes}}
\newcommand{\ROOT}{\textsc{Root}}
\newcommand{\lhe}{\textsc{Lhe}}
\newcommand{\lhco}{\textsc{Lhco}}
\newcommand{\hepmc}{\textsc{HepMC}}
\newcommand{\stdhep}{\textsc{StdHep}}
\newcommand{\INSP}{\textsc{Inspire}}
\newcommand{\python}{\textsc{Python}}
\newcommand{\spla}{\textsc{SampleAnalyzer}}
%latin
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\etc}{\textit{etc.}}

% environments
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bsp#1\esp{\begin{split}#1\end{split}}






\begin{document}
\begin{center} 
{\color{ao} \huge \textbf{\textsc{MadAnalysis} 5 v1.6}} \\ \vspace{0.25cm}
{\color{ao} \huge \textbf{Expert-Mode reference card}} \\ \vspace{0.25cm}
\vspace{0.1cm} \textsl{\today}\\
\vspace{0.1cm} \textsl{website: \url{http://madanalysis.irmp.ucl.ac.be/}}\\
\vspace{0.1cm} \textsl{references: \href{https://arxiv.org/abs/1206.1599}{arXiv:1206.1599[hep-ph]}, \href{https://arxiv.org/abs/1405.3982}{arXiv:1405.3982[hep-ph]}, \href{https://arxiv.org/abs/1407.3278}{arXiv:1407.3278[hep-ph]}}
\end{center}

\hspace{0.5cm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Creating an analysis template in the expert mode}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent For sophisticated analysis going beyond the capabilities of the normal mode of
running of \MA, the user has to rely on the so-called expert mode, where
analyses are implemented directly in the C++ framework of the platform. A blank
template analysis can be generated by typing, in a shell,
{\color{ao}\begin{verbatim}
  bin/ma5 --expert      bin/ma5 -e      bin/ma5 -E
\end{verbatim}}
\noindent \MA\ then asks information about the name of the working directory to create, as
well as information on the name of the analysis class that will have to be
designed. Those two pieces of information can be provided as arguments when
calling \MA\ from the shell,
{\color{ao}\begin{verbatim}
  bin/ma5 -E <dirname> <analysis>
\end{verbatim}}
\noindent where \verb+<dirname>+ consists in the working directory name, and
\verb+analysis+ the name of the analysis class.\\

\noindent For a proper use of the program, the user has to setup some environment
variables accordingly. This can be done by entering the \verb+Build+ subfolder
of the working directory and typing in a shell,
{\color{ao}\begin{verbatim}
  source setup.sh         source setup.csh
\end{verbatim}}
\noindent depending on the shell nature. The \verb+Build+ folder also contains a makefile
allowing for standard \verb+make+ commands,
{\color{ao}\begin{verbatim}
  make clean       make proper       make
\end{verbatim}}
\noindent The first command allows one to remove all intermediate object and backup
files whilst the second command yields the removal of all files that have been
created by the make action. Finally, the last command allows to build the code.\\

\noindent The code can then be run from the \verb+Build+
directory by typing,
{\color{ao}\begin{verbatim}
  MadAnalysis5Job [options] [inputfile]
\end{verbatim}}
\noindent The file {\color{ao}\verb?[inputfile]?} consists in a text file with a list of paths
pointing to the event samples to analyze, with one filename per line. Several
options are available, as summarized in the table below.
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{l p{8.4cm}}
\hline
Option & Description\\
\hline
\color{ao}\verb?--check_event?      & Sanity check of the input file.\\
\color{ao}\verb?--no_event_weight?  & Ignores the event weights.\\
\color{ao}\verb?--ma5_version=XXXX? & Allows to specify which version of the \MA\ console
  to use.\\
\hline
\end{tabular}
\end{center}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Portable datatypes}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent The \spla\ data format includes several portable data types, that we
show in the table below together with the corresponding bit width.
\renewcommand{\arraystretch}{1.1}%
\begin{center}\begin{tabular}{l l p{8.0cm}}
\hline
Name & Bit width & Description\\
\hline
\color{ao} \verb?MAbool?    & 1  & Boolean.\\
\hline
\color{ao}\verb?MAint8?    & 8  & Byte integer.\\
\color{ao}\verb?MAint16?   & 16 & Short integer.\\
\color{ao}\verb?MAint32?   & 32 & Integer.\\
\color{ao}\verb?MAint64?   & 64 & Long integer.\\
\hline
\color{ao}\verb?MAuint8?   & 8  & Unsigned byte integer.\\
\color{ao}\verb?MAuint16?  & 16 & Unsigned short integer.\\
\color{ao}\verb?MAuint32?  & 32 & Unsigned integer.\\
\color{ao}\verb?MAuint64?  & 64 & Unsigned long integer.\\
\hline
\color{ao} \verb?MAfloat32? & 32 & Single-precision floating-point number.\\
{\color{ao} \verb?MAfloat64?} or {\color{ao} \verb?MAdouble64?}  & 64 & Double-precision
   floating-point number.\\
\hline
\end{tabular}
\end{center}
Moreover, four-vectors can be implemented as instances of the
{\color{ao}\verb+MALorentzVector+} class that contains the same methods as the \ROOT\
{\color{ao}\verb+TLorentzVector+} class~\cite{Brun:1997pa}.

\vspace{2cm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Data format for an event sample}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent The analysis class contains an {\color{ao}\verb+Initialize+}, an {\color{ao}\verb+Execute+} and a
{\color{ao}\verb+Finalize+} method that are respectively executed before starting to read an
event sample, on each event and after having read all events. The {\color{ao}\verb+Execute+}
method requires two arguments, an instance of the {\color{ao}\verb+SampleFormat+} class and
an event passed as an {\color{ao}\verb+EventFormat+} instance (see the next subsection).
Monte Carlo event samples are generally accompanied with global information on
the sample, such as the identifier of the parton density set that has been used
or the total cross section associated with the described process. Those pieces
of information are stored as attributes of the above-mentioned
{\color{ao}\verb+SampleFormat+} object, and can be retrieved through the methods given in
the table below (in particular through attributes of the {\color{ao}\verb+mc()+} and
{\color{ao}\verb+rec()+} objects) on run time.
\verbdef{\expa}{const std::vector<std::string>& header() const}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{l p{6.2cm}}
\hline
Method name and type & Description\\
\hline
\color{ao}\verb+MCSampleFormat* mc()+            & Monte Carlo information (see below).\\
\color{ao}\verb+RecSampleFormat* rec()+          & Reconstruction information (see below).
    \\
\color{ao}\verb+const std::string name()+        & Sample name.\\
\color{ao}\verb+const MAuint64& nevents() const+ & Number of events in the sample.\\
\multicolumn{2}{l}{\color{ao}\expa}\\    &  Sample header.\\
\hline
\end{tabular}
\end{center}
The Monte Carlo information is available through the {\color{ao}\verb+mc()+} object, a
pointer to an instance of the {\color{ao}\verb+MCSampleFormat+} class whose attributes are
given in the table below.
\verbdef{\expb}{const std::pair<MAint32,MAint32>& beamPDGID() const}
\verbdef{\expc}{const std::pair<MAuint32,MAuint32>& beamPDFauthor() const}
\verbdef{\expd}{const MAint32& weightMode() const}
\verbdef{\expe}{const MAfloat64& xsection() const}
\verbdef{\expf}{const MAfloat64& xsection_error() const}
\verbdef{\expg}{const MAfloat64& sumweight_positive() const}
\verbdef{\exph}{const MAfloat64& sumweight_negative() const}
\verbdef{\expi}{const std::vector<ProcessFormat>& processes()}
\verbdef{\expj}{const WeightDefinition& weight_definition()}
\verbdef{\expk}{const std::pair<MAfloat64,MAfloat64>& beamE() const}
\verbdef{\expl}{const std::pair<MAuint32,MAuint32>& beamPDFID() const}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{l p{8.2cm}}
\hline
Method name and type & Description\\
\hline
\multicolumn{2}{l}{\color{ao}\expb}\\    &
  PDG codes of the intial partons.\\
\multicolumn{2}{l}{\color{ao}\expk}\\    &
  Beam energy.\\
\multicolumn{2}{l}{\color{ao}\expc}\\    &
  Group associated with the used parton density set.\\
\multicolumn{2}{l}{\color{ao}\expl}\\    &
  Identifier of the used parton density set.\\
\multicolumn{2}{l}{\color{ao}\expd}\\    &
  Information on the event weights.\\
\multicolumn{2}{l}{\color{ao}\expe}\\    &
  Cross section associated with the sample.\\
\multicolumn{2}{l}{\color{ao}\expf}\\    &
  Uncertainty on the sample cross section.\\
\multicolumn{2}{l}{\color{ao}\expg}\\    &
  Sum of the weights of all positively-weighted events.\\
\multicolumn{2}{l}{\color{ao}\exph}\\    &
  Sum of the weights of all negatively-weighted events.\\
\multicolumn{2}{l}{\color{ao}\expi}\\    &
  List of all described processes (see below).\\
\multicolumn{2}{l}{\color{ao}\expj}\\    &
  Definitions of the different weights for events featuring multiple weights.\\
\hline
\end{tabular}
\end{center}
Those attributes rely on two classes, the {\color{ao}\verb+ProcessFormat+} one allowing
for the description of a physical process and the {\color{ao}\verb+WeightDefinition+} one
connected to the potential assignment of multiple weights to a given
event\cite{Andersen:2014efa}. Whilst the
following methods have been implemented for the former class,
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{l p{4.8cm}}
\hline
Method name and type & Description\\
\hline
\color{ao}\verb+const MAfloat64& xsection() const+ & Associated cross section.\\
\color{ao}\verb+const MAfloat64& xsectionError() const+ & Error on the cross
  section.\\
\color{ao}\verb+const MAfloat64& weightMax() const+ & Maximum weight for an event.\\
\color{ao}\verb+const MAuint32& processId() const+ & Process identification number.\\
\hline
\end{tabular}
\end{center}
the latter class only allows for listing the names of the set of weights
associated with each event,
{\color{ao}\begin{verbatim}
 void Print() const
\end{verbatim}}
\noindent The {\color{ao}\verb+rec()+} method of the {\color{ao}\verb+MCSampleFormat+} class consists in an
instance of the {\color{ao}\verb?RecSampleFormat?} class that does not come with any
built-in method. This is left for future developments.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Data format for an event}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent An event object possesses two attributes {\color{ao}\verb+mc()+} and {\color{ao}\verb+rec()+} that are
this time instances of the {\color{ao}\verb+MCEventFormat+} and {\color{ao}\verb+RecEventFormat+}
classes respectively. These two classes are respectively connected to Monte
Carlo events (as simulated by a Monte Carlo event generator) and reconstructed
events as obtained after gathering all final-state objects into reconstructed
physical objects to be used for specific analyses. The {\color{ao}\verb+MCEventFormat+}
class comes with the methods summarized in the following table.
\verbdef{\expzza}{const MCParticleFormat& MET() const}
\verbdef{\expzzb}{const MCParticleFormat& MHT() const}
\verbdef{\expzzc}{MCParticleFormat& MET() const}
\verbdef{\expzzd}{MCParticleFormat& MHT() const}

\verbdef{\expzze}{const std::vector<MCParticleFormat>& particles() const}
\verbdef{\expzzf}{const WeightCollection& multiweights() const}

\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{l p{5.5cm}}
\hline
\color{ao}\expzza  & Missing transverse energy\\
\color{ao}\expzzb & Missing transverse hadronic energy. \\
\color{ao}\verb+const MAfloat64& TET() const+ & Total (visible) transverse energy.\\
\color{ao}\verb+const MAfloat64& THT() const+ & Total hadronic transverse energy.\\
\color{ao}\verb+const MAfloat64& Meff() const+ & Effective mass
  $\bigg(\sum_{\rm jets} p_T + \slashed{E}_T\bigg)$.\\
\color{ao}\verb+const MAfloat64& alphaQED()  const+ & Used value for the electromagnetic
  coupling.\\
\color{ao}\verb+const MAfloat64& alphaQCD()  const+ & Used value for the strong
  coupling.\\
 \multicolumn{2}{l}{\color{ao}\expzzf}\\  & Container for all event weights.\\
 \multicolumn{2}{l}{\color{ao}\expzze}\\  & All particles of the event.\\
\color{ao}\verb+const MAuint32& processId() const+ & Identifier of the physical process
  related to the event.\\
\color{ao}\verb+const MAfloat64& scale() const+ & Factorization scale choice. \\
\color{ao}\verb+const MAfloat64& weight() const+ & Event weight.\\
\hline
\end{tabular}
\end{center}
Weights (as returned by the {\color{ao}\verb+multiweights()+} method) are stored as an
instance of the {\color{ao}\verb+WeightCollection+} class, which comes with the methods
given in the table below.
\verbdef{\expaaa}{const MAfloat64& Get(MAuint32 id) const}
\verbdef{\expaab}{const std::map<MAuint32,MAfloat64>& GetWeights() const}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expaaa}\\    & Weight value corresponding to
  the weight identifier {\color{ao}\verb+id+}.\\
\multicolumn{2}{l}{\color{ao}\expaab}\\    &  The full list of weights as identifier-value
  pairs.\\
\hline
\end{tabular}
\end{center}
As indicated above, the event particle content can be obtained via the method
{\color{ao}\verb+particles()+} of the {\color{ao}\verb+MCEventFormat+} class. This returns a vector of
{\color{ao}\verb+MCParticleFormat+} objects, each element corresponding to an
initial-state, a final-state or an intermediate-state particle. This class
inherits all methods available from the {\color{ao}\verb+ParticleBaseFormat+} class, that
are collected in the table below.
\verbdef{\expaac}{const MAfloat32 mt_met(const MALorentzVector& MET) const}
\verbdef{\expaad}{const MALorentzVector& momentum() const}
\verbdef{\expaae}{MALorentzVector& momentum()}
\verbdef{\expaaf}{const MAfloat32 dphi_0_pi(const ParticleBaseFormat* p) const}
\verbdef{\expaag}{const MAfloat32 dphi_0_pi(const ParticleBaseFormat& p) const}
\verbdef{\expaah}{const MAfloat32 dphi_0_2pi(const ParticleBaseFormat* p) const}
\verbdef{\expaai}{const MAfloat32 dphi_0_2pi(const ParticleBaseFormat& p) const}
\verbdef{\expaaj}{const MAfloat32 dr(const ParticleBaseFormat& p) const}
\verbdef{\expaak}{const MAfloat32 dr(const ParticleBaseFormat* p) const}
\verbdef{\expaal}{const MAfloat32 angle(const ParticleBaseFormat& p) const}
\verbdef{\expaam}{const MAfloat32 angle(const ParticleBaseFormat* p) const}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{l p{6.3cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expaae}\\
\multicolumn{2}{l}{\color{ao}\expaad}\\ & {Four-momentum.}\\
\color{ao}\verb+const MAfloat32 beta() const+ & Velocity (in $c$ units).\\
\color{ao}\verb+const MAfloat32 e() const+    & Energy.\\
\color{ao}\verb+const MAfloat32 et() const+   & Transverse energy.\\
\color{ao}\verb+const MAfloat32 eta() const+  & Pseudorapidity.\\
\color{ao}\verb+const MAfloat32 abseta() const+ & Pseudorapidity in absolute
  value.\\
\color{ao}\verb+const MAfloat32 gamma() const+ & Lorentz factor.\\
\color{ao}\verb+const MAfloat32 m() const+   & Invariant mass.\\
\color{ao}\verb+const MAfloat32 mt() const+  & Transverse mass.\\
\color{ao}\verb+const MAfloat32 phi() const+ & Azimuthal angle.\\
\color{ao}\verb+const MAfloat32 p() const+   & Magnitude of the momentum.\\
\color{ao}\verb+const MAfloat32 pt() const+  & Transverse momentum.\\
\color{ao}\verb+const MAfloat32 px() const+  & $x$-component of the momentum.\\
\color{ao}\verb+const MAfloat32 py() const+  & $y$-component of the momentum.\\
\color{ao}\verb+const MAfloat32 pz() const+  & $z$-component of the momentum.\\
\color{ao}\verb+const MAfloat32 r() const+   & Position in the $\eta-\phi$ plane.\\
\color{ao}\verb+const MAfloat32 theta() const+  & Polar angle.\\
\color{ao}\verb+const MAfloat32 y() const+ & Rapidity.\\
\hline
\end{tabular}
\end{center}
The {\color{ao}\verb+ParticleBaseFormat+} class also includes a set of methods that
involve the particle itself as well as another object. These are given in the
following table.
\renewcommand{\arraystretch}{1.1}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expaal}\\
\multicolumn{2}{l}{\color{ao}\expaam}\\ & Angular separation between the
  particle momentum and the momentum of another particle \verb+p+.\\
\multicolumn{2}{l}{\color{ao}\expaac}\\      & Transverse mass of the system made of
    the particle and the missing momentum.\\
\multicolumn{2}{l}{\color{ao}\expaaf}\\
\multicolumn{2}{l}{\color{ao}\expaag}\\ & Azimuthal separation between the particle
momentum and the momentum of another particle \verb+p+, normalized in $[0,\pi]$.
\\
\multicolumn{2}{l}{\color{ao}\expaah}\\
\multicolumn{2}{l}{\color{ao}\expaai}\\ & Azimuthal separation between the particle
  momentum and the momentum of another particle \verb+p+, normalized in $[0,
  2\pi]$.\\
\multicolumn{2}{l}{\color{ao}\expaaj}\\
\multicolumn{2}{l}{\color{ao}\expaak}\\ & Angular distance, in the $\eta-\phi$ plane,
  between the particle momentum and the momentum of another particle \verb+p+.\\
\hline
\end{tabular}
\end{center}
Moreover, the {\color{ao}\verb+MCParticleFormat+} class includes the extra methods
listed below.
\verbdef{\expbba}{const std::vector<MCParticleFormat*>& daughters() const}
\verbdef{\expbbb}{const std::vector<MCParticleFormat*>& mothers() const}
\verbdef{\expbbc}{const MALorentzVector& decay_vertex() const}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{l p{6.1cm}}
\hline
\color{ao}\verb+const MAfloat64& ctau() const+ & Particle decay length.\\
\color{ao}\verb+const MAbool& isPU()  const+ & Tests whether the particle belongs to the
  pile-up event.\\
\color{ao}\verb+const MAint32& pdgid()  const+ & PDG identifier of the particle.\\
\color{ao}\verb+const MAfloat32& spin() const+ & Cosine of the angle between the particle
  momentum and its spin vector, computed in the laboratory frame.\\
\color{ao}\verb+const MAint16& statuscode() const+& Code indicating the particle initial-,
intermediate- or final-state nature.\\
\multicolumn{2}{l}{\color{ao}\expbba}\\ & Particles in which the current particle
  decays into.\\
\multicolumn{2}{l}{\color{ao}\expbbb}\\ & Particles from which the current
  particle originates from.\\
\multicolumn{2}{l}{\color{ao}\expbbc}\\ & Spacetime position of the particle decay.\\
\hline
\end{tabular}
\end{center}

A slightly different format is available for reconstructed events. An event is
here provided as an instance of the {\color{ao}\verb+RecEventFormat+} class, which comes
with the following methods.
\verbdef{\expcca}{const std::vector<RecPhotonFormat>& photons() const}
\verbdef{\expccb}{const std::vector<RecLeptonFormat>& electrons() const}
\verbdef{\expccc}{const std::vector<RecLeptonFormat>& muons() const}
\verbdef{\expccd}{const std::vector<RecTauFormat>& taus() const}
\verbdef{\expcce}{const std::vector<RecJetFormat>& fatjets() const}
\verbdef{\expccf}{const std::vector<RecJetFormat>& jets() const}
\verbdef{\expccg}{const std::vector<RecJetFormat>& genjets() const}
\verbdef{\expcch}{const std::vector<RecTrackFormat>& tracks() const}
\verbdef{\expcci}{const std::vector<RecTowerFormat>& towers() const}
\verbdef{\expccj}{const std::vector<RecTrackFormat>& EFlowTracks() const}
\verbdef{\expcck}{const std::vector<RecParticleFormat>& EFlowPhotons() const}
\verbdef{\expccl}{const std::vector<RecParticleFormat>& EFlowNeutralHadrons() const}
\verbdef{\expccm}{const RecParticleFormat& MET() const}
\verbdef{\expccn}{const RecParticleFormat& MHT() const}
\verbdef{\expcco}{const MAfloat64& TET() const}
\verbdef{\expccp}{const MAfloat64& THT() const}
\verbdef{\expccq}{const MAfloat64& Meff() const}
\verbdef{\expccr}{const std::vector<const MCParticleFormat*>& MCHadronicTaus() const}
\verbdef{\expccs}{const std::vector<const MCParticleFormat*>& MCElectronicTaus() const}
\verbdef{\expcct}{const std::vector<const MCParticleFormat*>& MCMuonicTaus() const}
\verbdef{\expccu}{const std::vector<const MCParticleFormat*>& MCBquarks() const}
\verbdef{\expccv}{const std::vector<const MCParticleFormat*>& MCCquarks() const}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expcca}\\  & Reconstructed photons.\\
\multicolumn{2}{l}{\color{ao}\expccb}\\  & Reconstructed electrons.\\
\multicolumn{2}{l}{\color{ao}\expccc}\\  & Reconstructed muons.\\
\multicolumn{2}{l}{\color{ao}\expccd}\\  & Reconstructed hadronic taus.\\
\multicolumn{2}{l}{\color{ao}\expcce}\\  & Reconstructed fat jets.\\
\multicolumn{2}{l}{\color{ao}\expccf}\\  & Reconstructed jets.\\
\multicolumn{2}{l}{\color{ao}\expccg}\\  & Parton-level jets.\\
\multicolumn{2}{l}{\color{ao}\expcch}\\  & Tracks left in a detector.\\
\multicolumn{2}{l}{\color{ao}\expcci}\\  & Calorimetric deposits left in a detector.\\
\multicolumn{2}{l}{\color{ao}\expccj}\\  & Tracks left in a detector, reconstructed from
  the particle flow information.\\
\multicolumn{2}{l}{\color{ao}\expcck}\\  & Photons, reconstructed from the particle flow
  information.\\
\multicolumn{2}{l}{\color{ao}\expccl}\\  & Neutral hadrons, reconstructed from the
  particle flow information.\\
\multicolumn{2}{l}{\color{ao}\expccm}\\  & Missing transverse energy.\\
\multicolumn{2}{l}{\color{ao}\expccn}\\  & Missing hadronic energy.\\
\multicolumn{2}{l}{\color{ao}\expcco}\\  & Visible transverse energy.\\
\hline
\end{tabular}
\end{center}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expccp}\\  & Hadronic transverse energy.\\
\multicolumn{2}{l}{\color{ao}\expccq}\\  & Effective mass $\Big(\sum_{\rm jets} p_T +
   \slashed{E}_T\Big)$.\\
\multicolumn{2}{l}{\color{ao}\expccr}\\  & Parton-level taus that decayed hadronically.\\
\multicolumn{2}{l}{\color{ao}\expccs}\\  & Parton-level taus that decayed into an electron
  and missing energy. \\
\multicolumn{2}{l}{\color{ao}\expcct}\\  & Parton-level taus that decayed into a muon and
  missing energy. \\
\multicolumn{2}{l}{\color{ao}\expccu}\\  & Parton-level $b$-quarks of the event.\\
\multicolumn{2}{l}{\color{ao}\expccv}\\  & Parton-level $c$-quarks of the event.\\
\hline
\end{tabular}
\end{center}
The above methods introduce the data format implemented for all reconstructed
objects. It relies on various types ({\color{ao}\verb+RecLeptonFormat+},
{\color{ao}\verb+RecJetFormat+},
{\color{ao}\verb+RecPhotonFormat+}, {\color{ao}\verb+RecTauFormat+}, {\color{ao}\verb+RecTrackFormat+} and
{\color{ao}\verb+RecTowerFormat+)} that inherit from the {\color{ao}\verb+RecParticleFormat+} class
based on the {\color{ao}\verb+BaseParticleFormat+} class (see above).
All these new classes include the following set of methods.
\verbdef{\expdda}{const MAfloat32& HEoverEE() const}
\verbdef{\expddb}{const MAfloat32& EEoverHE() const}
\verbdef{\expddc}{const MAuint16 ntracks() const}
\verbdef{\expddd}{const int charge() const}
\verbdef{\expdde}{MAbool isElectron() const}
\verbdef{\expddf}{MAbool isMuon() const}
\verbdef{\expddg}{MAfloat32 d0() const}
\verbdef{\expddh}{MAfloat32 d0error() const}
\verbdef{\expddi}{const MAbool& btag() const}
\verbdef{\expddj}{const MAbool& ctag() const}
\verbdef{\expddk}{const MAbool& true_btag() const}
\verbdef{\expddl}{const MAbool& true_ctag() const}
\verbdef{\expddm}{const std::vector<MAint32>& constituents() const}
\verbdef{\expddn}{const MAint32 DecayMode() const}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expddb}\\  & Ratio of the electromagnetic to
  hadronic calorimetric energy associated with the object.\\
\multicolumn{2}{l}{\color{ao}\expdda}\\  & Ratio of the hadronic to
  electromagnetic calorimetric energy associated with the object.\\
\multicolumn{2}{l}{\color{ao}\expddn}\\  & Identifier of the decay mode of a
  \verb+RecTauFormat+ object. The available choices are 1 ($\tau\to e \nu \nu$),
  2 ($\tau \to \mu \nu \nu$),  3 ($\tau \to K \nu$), 4 ($\tau \to K^* \nu$),
  5 ($\tau \to \rho (\to \pi \pi^0) \nu$), 6 ($\tau \to a_1 (\to \pi\pi^0\pi^0)
  \nu$), 7 ($\tau \to a_1 (\to \pi\pi\pi) \nu$), 8 ($\tau \to \pi \nu$), 
  9 ($\tau \to \pi\pi\pi \pi^0 \nu$) and 0 (any other decay mode).\\
\multicolumn{2}{l}{\color{ao}\expddi}\\  & Indicates whether a {\color{ao}\verb+RecJetFormat+} object
  has been $b$-tagged.\\
\hline
\end{tabular}
\end{center}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expddj}\\  & Indicates whether a {\color{ao}\verb+RecJetFormat+} object
  has been $c$-tagged.\\
\multicolumn{2}{l}{\color{ao}\expddm}\\  & Returns the constituents of a
  {\color{ao}\verb+RecJetFormat+} object.\\
\multicolumn{2}{l}{\color{ao}\expddd}\\  & The electric charge of the object. This method
  is available for the {\color{ao}\verb+RecLeptonFormat+}, {\color{ao}\verb+RecTauFormat+} and
  {\color{ao}\verb+RecTrackFormat+} classes.\\
\multicolumn{2}{l}{\color{ao}\expddg}\\ & Impact parameter of a {\color{ao}\verb+RecLeptonFormat+}
  object. An extension to the other classes of reconstructed objects is
  foreseen.\\
\multicolumn{2}{l}{\color{ao}\expddh}\\ & Uncertainty on the impact parameter of a
  {\color{ao}\verb+RecLeptonFormat+} object.\\
\multicolumn{2}{l}{\color{ao}\expddc}\\ & Number of charged tracks associated with a
  reconstructed object. This method is available for the {\color{ao}\verb+RecJetFormat+} and
  {\color{ao}\verb+RecTauFormat+} classes.\\
\multicolumn{2}{l}{\color{ao}\expdde}\\ & Indicates if a {\color{ao}\verb+RecLeptonFormat+} object is
  an electron.\\
\multicolumn{2}{l}{\color{ao}\expddf}\\ & Indicates if a {\color{ao}\verb+RecLeptonFormat+} object is
  a muon.\\
\multicolumn{2}{l}{\color{ao}\expddk}\\  & Indicates whether a {\color{ao}\verb+RecJetFormat+} object
  is a true $b$-jet.\\
\multicolumn{2}{l}{\color{ao}\expddl}\\  & Indicates whether a {\color{ao}\verb+RecJetFormat+} object
  is a true $c$-jet.\\
\hline
\end{tabular}
\end{center}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Lepton and photon isolation}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the context of reconstructed events, lepton and photon isolation can be
ensured by relying either on track information, on calorimetric information, on
the combination of both or on a reconstruction based on the energy flow.
Corresponding isolation methods are available, within the \MA\ data format,
through the four classes,
{\color{ao}\begin{verbatim}
  PHYSICS->Isol->tracker           PHYSICS->Isol->calorimeter
  PHYSICS->Isol->combined          PHYSICS->Isol->eflow
\end{verbatim}}
respectively connected to the four ways to enforce object isolation. All
those classes come with two methods summarized in the table below.
\verbdef{\expyya}{MAfloat64 relIsolation(const <x>& prt,const RecEventFormat* evt,}
\verbdef{\expyyb}{       const double& DR, double PTmin=0.5) const}
\verbdef{\expyyc}{MAfloat64 sumIsolation(const <x>& prt,const RecEventFormat* evt,}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expyya}\\
\multicolumn{2}{l}{\color{ao}\expyyb}\\ & Sum of the transverse momenta of all objects
  lying in a cone of radius \verb+DR+ centered on the considered object
  {\color{ao}\verb+prt+}, and whose transverse momentum is larger than {\color{ao}\verb+PTmin+}. The sum
  is evaluated relatively to the transverse momentum of the considered object
  {\color{ao}\verb+prt+} that can be either a {\color{ao}\verb+RecLeptonFormat+} or a
  {\color{ao}\verb+RecPhotonFormat+} object ({\it i.e.} the value of the {\color{ao}\verb+<x>+} type).\\
\multicolumn{2}{l}{\color{ao}\expyyc}\\
\multicolumn{2}{l}{\color{ao}\expyyb}\\ & Sum of the transverse momenta of all objects
  lying in a cone of radius {\color{ao}\verb+DR+} centered on the considered object
  {\color{ao}\verb+prt+}, and whose transverse momentum is larger than {\color{ao}\verb+PTmin+}. The
  object {\color{ao}\verb+prt+} can be either a {\color{ao}\verb+RecLeptonFormat+} or a
  {\color{ao}\verb+RecPhotonFormat+} object ({\it i.e.} the value of the {\color{ao}\verb+<x>+} type).\\
\hline
\end{tabular}
\end{center}
When isolation is imposed on the basis of the energy flow
(\verb?PHYSICS->Isol->eflow?), those methods take an extra argument,
{\color{ao}
\begin{verbatim}
MAfloat64 relIsolation(const <x>& prt, const RecEventFormat* evt,
    const double& DR, double PTmin=0.5, ComponentType type) const

MAfloat64 sumIsolation(const <x>& prt, const RecEventFormat* evt,
    const double& DR, double PTmin=0.5, ComponentType type) const
\end{verbatim}
}
where {\color{ao}\verb+type+} can take one of the four values,
{\color{ao}\begin{verbatim}
 TRACK_COMPONENT                    PHOTON_COMPONENT
 NEUTRAL_COMPONENT                  ALL_COMPONENTS
\end{verbatim}}
In the first case, the activity around the considered object {\color{ao}\verb+prt+} is
evaluated only from the charged track information, whilst in the
second case, only the photon information is considered. In the
third case, the neutral hadron activity is accounted for whilst the last option
consists in the sum of the three previous cases.

In addition, a series of {\color{ao}\verb+JetCleaning+} functions are provided in the aim of
cleaning jet collections from objects present in a lepton collection or a photon
collection.
\verbdef{\expwwa}{std::vector<const RecJetFormat*> PHYSICS->Isol->JetCleaning(}
\verbdef{\expwwb}{   const std::vector<const RecJetFormat*>& uncleaned,}
\verbdef{\expwwc}{   const std::vector<const RecLeptonFormat*>& leptons,}
\verbdef{\expwwd}{   double DeltaRmax = 0.1, double PTmin = 0.5) const}
\verbdef{\expwwe}{   const std::vector<RecJetFormat>& uncleaned,}
\verbdef{\expwwf}{   const std::vector<const RecPhotonFormat*>& photons,}
\renewcommand{\arraystretch}{1.13}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expwwa}\\
\multicolumn{2}{l}{\color{ao}\expwwb}\\
\multicolumn{2}{l}{\color{ao}\expwwc}\\
\multicolumn{2}{l}{\color{ao}\expwwd}\\
\multicolumn{2}{l}{\color{ao}\expwwa}\\
\multicolumn{2}{l}{\color{ao}\expwwe}\\
\multicolumn{2}{l}{\color{ao}\expwwc}\\
\multicolumn{2}{l}{\color{ao}\expwwd}\\ & Removal from the \verb+uncleaned+ jet collection
  of all leptons included in the \verb+leptons+ collection lying at an angular
  distance of at most \verb+DeltaRmax+ of the jet, and whose transverse momentum
  is of at least \verb+PTmin+.\\
\multicolumn{2}{l}{\color{ao}\expwwa}\\
\multicolumn{2}{l}{\color{ao}\expwwb}\\
\multicolumn{2}{l}{\color{ao}\expwwf}\\
\multicolumn{2}{l}{\color{ao}\expwwd}\\
\multicolumn{2}{l}{\color{ao}\expwwa}\\
\multicolumn{2}{l}{\color{ao}\expwwe}\\
\multicolumn{2}{l}{\color{ao}\expwwf}\\
\multicolumn{2}{l}{\color{ao}\expwwd}\\ & Removal from the {\color{ao}\verb+uncleaned+} jet collection
  of all photons included in the {\color{ao}\verb+photons+} collection lying at an angular
  distance of at most {\color{ao}\verb+DeltaRmax+} of the jet, and whose transverse momentum
  is of at least {\color{ao}\verb+PTmin+}.\\
\hline
\end{tabular}
\end{center}

\vspace{2cm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Observables}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent The \spla\ data format contains various methods to compute observables
connected to the entire event, which includes in particular a small set of
common transverse variables and a set of methods related to object
identification. They are available through a series of \verb+PHYSICS+ services,
that first contain  the two general methods below.
\verbdef{\expxxa}{MAint32 PHYSICS->GetTauDecayMode (const MCParticleFormat* part)}
\verbdef{\expxxb}{double PHYSICS->SqrtS(const MCEventFormat* event) const}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expxxa}\\ & Returns the identifier of the decay mode of a
  tau particle. The available values are 1 ($e \nu \nu$),
  2 ($\mu \nu \nu$),  3 ($K \nu$), 4 ($K^* \nu$),
  5 ($\rho (\to \pi \pi^0) \nu$), 6 ($a_1 (\to \pi\pi^0\pi^0)
  \nu$), 7 ($a_1 (\to \pi\pi\pi) \nu$), 8 ($\pi \nu$),
  9 ($\pi\pi\pi \pi^0 \nu$) and 0 (any other decay mode).\\
\multicolumn{2}{l}{\color{ao}\expxxb}\\ & Returns the partonic center-of-mass energy.\\
\hline
\end{tabular}
\end{center}
Identification functions are collected as methods attached to the
{\color{ao}\verb+PHYSICS->Id+} object. The list of available methods is given in the table
below.
\verbdef{\expxxc}{MAbool IsInitialState(const MCParticleFormat& part) const}
\verbdef{\expxxd}{MAbool IsFinalState(const MCParticleFormat& part) const}
\verbdef{\expxxe}{MAbool IsInterState(const MCParticleFormat& part) const}
\verbdef{\expxxf}{MAbool IsInitialState(const MCParticleFormat* part) const}
\verbdef{\expxxg}{MAbool IsFinalState(const MCParticleFormat* part) const}
\verbdef{\expxxh}{MAbool IsInterState(const MCParticleFormat* part) const}
\verbdef{\expxxj}{bool IsHadronic(const RecParticleFormat* part) const}
\verbdef{\expxxk}{bool IsHadronic(const MCParticleFormat* part) const}
\verbdef{\expxxl}{bool IsHadronic(MAint32 pdgid) const}
\verbdef{\expxxm}{bool IsInvisible(const RecParticleFormat* part) const}
\verbdef{\expxxn}{bool IsInvisible(const MCParticleFormat* part) const}
\verbdef{\expxxo}{MAbool IsBHadron(MAint32 pdg)}
\verbdef{\expxxp}{MAbool IsBHadron(const MCParticleFormat& part)}
\verbdef{\expxxq}{MAbool IsBHadron(const MCParticleFormat* part)}
\verbdef{\expxxs}{MAbool IsCHadron(MAint32 pdg)}
\verbdef{\expxxt}{MAbool IsCHadron(const MCParticleFormat& part)}
\verbdef{\expxxu}{MAbool IsCHadron(const MCParticleFormat* part)}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expxxc}\\
\multicolumn{2}{l}{\color{ao}\expxxf}\\ & Tests the initial-state nature of an object.\\
\multicolumn{2}{l}{\color{ao}\expxxh}\\
\multicolumn{2}{l}{\color{ao}\expxxe}\\ & Tests the intermediate-state nature of an
  object.\\
\multicolumn{2}{l}{\color{ao}\expxxd}\\
\multicolumn{2}{l}{\color{ao}\expxxg}\\ & Tests the final-state nature of an object.\\
\multicolumn{2}{l}{\color{ao}\expxxj}\\
\multicolumn{2}{l}{\color{ao}\expxxk}\\
\multicolumn{2}{l}{\color{ao}\expxxl}\\ & Tests the hadronic nature of an object.\\
\multicolumn{2}{l}{\color{ao}\expxxm}\\
\multicolumn{2}{l}{\color{ao}\expxxn}\\ & Tests the invisible nature of an object.\\
\multicolumn{2}{l}{\color{ao}\expxxo}\\
\multicolumn{2}{l}{\color{ao}\expxxp}\\
\multicolumn{2}{l}{\color{ao}\expxxq}\\ & Tests whether the object is a $B$-hadron.\\
\multicolumn{2}{l}{\color{ao}\expxxs}\\
\multicolumn{2}{l}{\color{ao}\expxxt}\\
\multicolumn{2}{l}{\color{ao}\expxxu}\\ & Tests whether the object is a $C$-hadron.\\
\hline
\end{tabular}
\end{center}
Finally, a set of transverse variables can be evaluated by relying on the
{\color{ao}\verb+PHYSICS->Transverse+} object. The following methods are available within
the \spla\ data format.
\verbdef{\expqqa}{double EventTET(const MCEventFormat* event) const}
\verbdef{\expqqb}{double EventTET(const RecEventFormat* event) const}
\verbdef{\expqqc}{double EventMET(const MCEventFormat* event) const}
\verbdef{\expqqd}{double EventMET(const RecEventFormat* event) const}
\verbdef{\expqqe}{double EventTHT(const MCEventFormat* event) const}
\verbdef{\expqqf}{double EventTHT(const RecEventFormat* event) const}
\verbdef{\expqqg}{double EventMEFF(const MCEventFormat* event) const}
\verbdef{\expqqh}{double EventMEFF(const RecEventFormat* event) const}
\verbdef{\expqqi}{double EventMHT(const MCEventFormat* event) const}
\verbdef{\expqqj}{double EventMHT(const RecEventFormat* event) const}
\verbdef{\expqqka}{double MT2(const MALorentzVector* p1, const MALorentzVector* p2,}
\verbdef{\expqqkb}{   const MALorentzVector& met, const double &mass)}
\verbdef{\expqqla}{double MT2W(std::vector<const RecJetFormat*> jets,}
\verbdef{\expqqlb}{   const RecLeptonFormat* lep, const ParticleBaseFormat& met)}
\verbdef{\expqqma}{double MT2W(std::vector<const MCParticleFormat*> jets}
\verbdef{\expqqmb}{  const MCParticleFormat* lep,const ParticleBaseFormat& met)}
\verbdef{\expqqn}{double AlphaT(const MCEventFormat*)}
\verbdef{\expqqo}{double AlphaT(const RecEventFormat*)}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expqqn}\\
\multicolumn{2}{l}{\color{ao}\expqqo}\\ & The $\alpha_T$ variable\cite{Randall:2008rw}.\\
\multicolumn{2}{l}{\color{ao}\expqqg}\\
\multicolumn{2}{l}{\color{ao}\expqqh}\\ & The effective mass of the event.\\
\hline
\end{tabular}
\end{center}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\expqqc}\\
\multicolumn{2}{l}{\color{ao}\expqqd}\\ & The event missing transverse energy.\\
\multicolumn{2}{l}{\color{ao}\expqqi}\\
\multicolumn{2}{l}{\color{ao}\expqqj}\\ & The event missing transverse hadronic energy.\\
\multicolumn{2}{l}{\color{ao}\expqqa}\\
\multicolumn{2}{l}{\color{ao}\expqqb}\\ & The event total transverse energy.\\
\multicolumn{2}{l}{\color{ao}\expqqe}\\
\multicolumn{2}{l}{\color{ao}\expqqf}\\ & The event total transverse hadronic energy.\\
\multicolumn{2}{l}{\color{ao}\expqqka}\\
\multicolumn{2}{l}{\color{ao}\expqqkb}\\ & The event $m_{T2}$ variable computed from a system
  of two visible objects \verb+p1+ and \verb+p2+, the event missing momentum
  \verb+met+ and a test mass \verb+mass+\cite{Lester:1999tx,Cheng:2008hk}.\\
\multicolumn{2}{l}{\color{ao}\expqqla}\\
\multicolumn{2}{l}{\color{ao}\expqqlb}\\
\multicolumn{2}{l}{\color{ao}\expqqma}\\
\multicolumn{2}{l}{\color{ao}\expqqmb}\\ & The event $m_{T2}^W$ variable computed from a
  system of jets \verb+jets+, a lepton \verb+lep+ and the missing
  momentum \verb+met+~\cite{Bai:2012gs}.\\
\hline
\end{tabular}
\end{center}

\vspace{2cm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Signal regions, histograms and cuts}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The implementation of an analysis in \MA\ requires to deal with
signal regions, selection cuts and histograms. Each analysis comes with an
instance of the analysis manager class {\color{ao}\verb+RegionSelectionManager+}, named
{\color{ao}\verb+Manager()+}, which allows the user to use the methods presented in the
table below.
\verbdef{\SRa}{void AddCut(const std::string&name, const std::string &RSname)}
\verbdef{\SRba}{template<int NRS> void AddCut(const std::string&name,}
\verbdef{\SRbb}{  std::string const(& RSnames)[NRS])}
\verbdef{\SRbc}{void AddCut(const std::string &name)}
\verbdef{\SRca}{void AddHisto(const std::string&name,unsigned int nb,}
\verbdef{\SRcb}{  double xmin, double xmax)}
\verbdef{\SRcd}{void AddHistoLogX(const std::string&name,unsigned int nb,}
\verbdef{\SRce}{  double xmin, double xmax, const std::string &RSname)}
\verbdef{\SRcf}{template <int NRS> void AddHisto(const std::string&name,}
\verbdef{\SRcg}{  unsigned int nb, double xmin, double xmax,}
\verbdef{\SRch}{template <int NRS> void AddHistoLogX(const std::string&name,}
\verbdef{\SRd}{void AddRegionSelection(const std::string& name)}
\verbdef{\SRe}{bool ApplyCut(bool cond, std::string const &name)}
\verbdef{\SRf}{void FillHisto(std::string const&name, double val)}
\verbdef{\SRg}{void InitializeForNewEvent(double EventWeight)}
\verbdef{\SRh}{bool IsSurviving(const std::string &RSname)}
\verbdef{\SRi}{void SetCurrentEventWeight(double weight)}
\renewcommand{\arraystretch}{1.1}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\SRa}\\\multicolumn{2}{l}{\SRba}\\
  \multicolumn{2}{l}{\color{ao}\SRbb}\\
  \multicolumn{2}{l}{\color{ao}\SRbc}\\&
  Declares a cut named \verb+name+ and associates it with one region (the second
  argument is a string), with a set of regions (the second argument is an
  array of strings) or with all regions (the second argument is omitted).\\
\hline
\end{tabular}
\end{center}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\SRca}\\ \multicolumn{2}{l}{\SRcb}\\
  \multicolumn{2}{l}{\color{ao}\SRcd}\\ \multicolumn{2}{l}{\SRcb}\\&
  Declares a histogram named \verb+name+ of \verb+nb+ bins ranging from
  \verb+xmin+ to \verb+xmax+. The histogram is associated with all regions and
  the $x$-axis can rely on a logarithmic scale (the second method).\\
\multicolumn{2}{l}{\color{ao}\SRca}\\ \multicolumn{2}{l}{\SRce}\\
  \multicolumn{2}{l}{\color{ao}\SRcd}\\ \multicolumn{2}{l}{\SRce}\\&
  Same as above but the histogram is associated with a single region
  \verb+RSname+.\\
\multicolumn{2}{l}{\color{ao}\SRcf}\\ \multicolumn{2}{l}{\SRcg}\\
  \multicolumn{2}{l}{\color{ao}\SRbb}\\
  \multicolumn{2}{l}{\color{ao}\SRch}\\ \multicolumn{2}{l}{\SRcg}\\
  \multicolumn{2}{l}{\color{ao}\SRbb}\\ &
  Same as above but the histogram is associated with an array of regions.\\
\multicolumn{2}{l}{\color{ao}\SRd}\\ &
  Declares a new region named \verb+name+.\\
\multicolumn{2}{l}{\color{ao}\SRe}\\ &
  Applies the cut \verb+name+, an event passing this cut if the condition
  \verb+cond+ is realized. The method returns \texttt{true} if at least one
  region is passing all cuts applied so far, or \texttt{false} otherwise.\\
\multicolumn{2}{l}{\color{ao}\SRf}\\ &
  Fills the histogram named \verb+name+, the bin choice being driven by the
  value \verb+value+.\\
\multicolumn{2}{l}{\color{ao}\SRg}\\ &
  To be called at the beginning of the analysis of an event in order to tag all
  regions as surviving the cuts and initialize the event weight to the value
  \verb+EventWeight+.\\
\hline
\end{tabular}
\end{center}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{p{2.7cm} p{9.0cm}}
\hline
\multicolumn{2}{l}{\color{ao}\SRh}\\ &
  Verifies whether the region \verb+RSname+ survives all cut applied so far.\\
\multicolumn{2}{l}{\color{ao}\SRi}\\ &
  Modifies the weight of the current event to the value \verb+weight+.\\
\hline
\end{tabular}
\end{center}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Message services}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent\spla\ handles four levels of streamers, that can be cast within any analysis
code by typing one of the following lines,
{\color{ao}
\begin{verbatim}
 INFO    << "..." << endmsg;
 WARNING << "..." << endmsg;
 ERROR   << "..." << endmsg;
 DEBUG   << "..." << endmsg;
\end{verbatim}}
\noindent This allows the user to print informative, warning, error and debugging
messages. Additionally, warning and error messages return information on the
line number responsible for printing the message.
The effect of a given message service can be modified by
means of the methods presented in the table below.
\verbdef{\ina}{void SetStream(std::ostream* stream)}
\renewcommand{\arraystretch}{1.2}%
\begin{center}\begin{tabular}{l p{8.3cm}}
\hline
\color{ao}\verb+void DisableColor()+ & Switches off the colored display of messages (that
  is on by default).\\
\color{ao}\verb+void EnableColor()+  & Switches on the colored display of messages.\\
\color{ao}\verb+void SetMute()+      & Switches entirely off a given message service (that
  is on by default).\\
\multicolumn{2}{l}{\color{ao}\ina}\\ & Redirects the output of a given service to a file.
  \\
\color{ao}\verb+void SetUnMute()+   & Switches on a specific message service.\\
\hline
\end{tabular}
\end{center}

\vspace{2cm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{shaded}
\section{\Large Sorting particles and objects}
\end{shaded}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent It is usually important to order particle as a function of one of their
properties, like their transverse momentum or their energy. For this reason,
\spla\ contains a series of routines allowing to sort a set of objects, which
can be called by implementing\\
{\color{ao}
\begin{verbatim}
  SORTER->sort(objects, criterion)
\end{verbatim}}
\noindent where {\color{ao}\verb+objects+} is the vector of objects that needs to be sorted and
\verb+criterion+ is the ordering variable. The latter can be {\color{ao}\verb+ETAordering+}
(pseudorapidity), {\color{ao}\verb+ETordering+} (transverse energy), {\color{ao}\verb+Eordering+}
(energy), {\color{ao}\verb+Pordering+} (the magnitude of the three-momentum),
{\color{ao}\verb+PTordering+} (the transverse momentum), {\color{ao}\verb+PXordering+} (the
$x$-component of the momentum), {\color{ao}\verb+PYordering+} (the $y$-component of the
momentum) and {\color{ao}\verb+PZordering+} (the $z$-component of the momentum). As a
result, the vector of objects is sorted by decreasing values of the ordering
variable.

\newpage

\bibliographystyle{plain} % We choose the "plain" reference style
\bibliography{main_expert}

\end{document}
